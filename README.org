#+PROPERTY: header-args:emacs-lisp :tangle config.el :comments no :mkdirp yes :prologue "(unless (bound-and-true-p lexical-binding) (princ \";;; -*- lexical-binding: t -*-\\n\"))"
#+title: Emacs Config
* ThornEmacs

ThornEmacs is my personalized configuration of emacs, using the
[[https://github.com/nix-community/emacs-overlay][emacs-overlay for nixpkgs]]. Customized to enhance productivity and
devolopment workflows...and basically function like my neovim config:
[[https://github.com/Elias-Ainsworth/thornevim][ThorneVim]].

* Features

- A custom function to toggle between `eglot (default)` and `lsp-mode`.
- A custom function to set the background to a the background color
  determinied by wallust.
Among other things (I'll get to this once I actually finish this
damned config).

* Installation

** NixOS
:PROPERTIES:
:CUSTOM_ID: nix-install
:END:

Include the following input in your `flake.nix` file:

#+begin_src nix :tangle no
{
  input.thornemacs.url = "github:Elias-Ainsworth/thornemacs";
}
#+end_src

Then include it in your `environment.systemPackages` or
`home.packages` by referencing the input:

#+begin_src nix :tangle no
  input.thornemacs.packages.${pkgs.system}.default
#+end_src

Alternatively, it can also be run directly:

#+begin_src console :tangle no
nix run github:Elias-Ainsworth/thornemacs
#+end_src

Overrides coming soon...

** Legacy *NIX based operating systems

1. [[https://nix-community.github.io/home-manager/][Install home-manager]]
2. Then go back to the section on [[#nix-install][NixOS]] and follow those steps.

* Configuration

To configure this...configuration to your liking:
1. If the configuration involves a package add it to the
   `extraEmacsPackages` section in [[file:default.nix][default.nix]].
2. Set it up by editing this file (yes the README file) under the
   [[#actual-config][actual config]] section.

* Usage

You're kidding me right? It's emacs (with evil-mode)...use it like
emacs (with evil-mode).

* Documentation

This is more for my reference than anything else. But if you would
like to view my documentation, check out [[file:docs/][./docs]].

* Hacking
Just use `nix develop`

* The Actual Config
:PROPERTIES:
:CUSTOM_ID: actual-config
:END:

** Lexical Binding

#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src

** Performance Tweaks

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 50 1000 1000))
(add-hook 'emacs-startup-hook
          (lambda () (setq gc-cons-threshold (* 2 1000 1000))))
#+end_src

** Auto-Tangle on Save

#+begin_src emacs-lisp
(defun auto-tangle-config ()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "init.org" user-emacs-directory))
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'after-save-hook #'auto-tangle-config nil 'local)))
#+end_src

** Package Setup

#+begin_src emacs-lisp
(require 'package)
(setq package-enable-at-startup nil)
#+end_src

** Bootstrap `use-package`

#+begin_src emacs-lisp
(require 'use-package)
(setq use-package-always-ensure t
      use-package-always-defer t
      use-package-expand-minimally t)
#+end_src

** Evil Mode

#+begin_src emacs-lisp
;; Prevent conflicts with evil-collection
(setq evil-want-keybinding nil)

(use-package evil
  :demand t
  :init
  :config
  (evil-mode 1))

 (use-package evil-collection
   :after evil
   :config (evil-collection-init))

(use-package embrace)

(use-package evil-embrace
  :after (evil embrace)
  :config (evil-embrace-enable-evil-surround-integration))

(use-package evil-commentary
  :after evil
  :init (evil-commentary-mode 1))
#+end_src

** UI


*** Disable Default GUI Elements

#+begin_src emacs-lisp
  ;; Disable UI chrome early
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  (setq window-divider-default-right-width 0)
  (setq window-divider-default-bottom-width 0)
  (window-divider-mode -1)

  (add-to-list 'default-frame-alist '(internal-border-width . 0))
  (set-frame-parameter nil 'internal-border-width 0)
#+end_src

*** Font sizing

#+begin_src emacs-lisp
(let ((current-font (face-attribute 'default :family)))
  (set-face-attribute 'default nil
    :family current-font
    :height 120))
#+end_src

*** Theme - Catppuccin

#+begin_src emacs-lisp
(use-package catppuccin-theme
  :config (setq catppuccin-flavor 'mocha)
  :init (load-theme 'catppuccin :no-confirm))

(add-hook 'server-after-make-frame-hook #'catppuccin-reload)
#+end_src

*** Wallust Integration

#+begin_src emacs-lisp
(require 'json)
(require 'filenotify)

;; Path to your Wallust JSON
(defvar thornemacs/wallust-json-path "~/.cache/wallust/nix.json")

;; Watch descriptor
(defvar thornemacs/wallust-watch-descriptor nil)

;; Function to load background from Wallust JSON
(defun thornemacs/load-wallust-bg-from-json ()
  "Load background color from Wallust JSON and apply it to default face."
  (interactive)
  (when (file-exists-p thornemacs/wallust-json-path)
    (let* ((json-object-type 'alist)
           (json (with-temp-buffer
                   (insert-file-contents thornemacs/wallust-json-path)
                   (json-read)))
           (bg (alist-get 'background (alist-get 'special json))))
      (when (and bg (stringp bg))
        (set-face-background 'default bg)
        (set-face-background 'fringe bg)
        (message "Set background to: %s" bg)))))

;; Watcher function
(defun thornemacs/start-wallust-bg-watcher ()
  "Start watching the Wallust JSON file for background changes."
  (interactive)
  (unless (and thornemacs/wallust-watch-descriptor
               (file-notify-valid-p thornemacs/wallust-watch-descriptor))
    (when (file-exists-p thornemacs/wallust-json-path)
      (setq thornemacs/wallust-watch-descriptor
            (file-notify-add-watch
             thornemacs/wallust-json-path
             '(change)
             (lambda (_event) (thornemacs/load-wallust-bg-from-json)))))
    (message "Started watching Wallust JSON for background updates.")))

;; Optional: start the watcher immediately
(thornemacs/load-wallust-bg-from-json)
(thornemacs/start-wallust-bg-watcher)
#+end_src

*** Transparency

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 80))
(set-frame-parameter nil 'alpha-background 80)
(set-face-background 'default nil (selected-frame))
#+end_src

*** Dashboard

#+begin_src emacs-lisp
(use-package dashboard
  :demand t
  :init
  ;; Delay initial-buffer-choice until after dashboard loads
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  :config
  (dashboard-setup-startup-hook)

  ;; Banner and layout
  (setq dashboard-startup-banner 'official) ; You can use a custom path too
  (setq dashboard-center-content t)
  (setq dashboard-show-shortcuts nil)

  ;; Dashboard items
  (setq dashboard-items '((recents  . 5)
                          (projects . 5)
                          (agenda   . 5))))
#+end_src

*** Modeline

#+begin_src emacs-lisp
(use-package nerd-icons)

(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :init
  (setq doom-modeline-height 25
        doom-modeline-bar-width 3
        doom-modeline-icon t
        doom-modeline-major-mode-icon t
        doom-modeline-buffer-file-name-style 'truncate-upto-project))
#+end_src

*** Indent Guides

#+begin_src emacs-lisp
(defun thornemacs/enable-indent-guides-safe ()
  (when (face-background 'default)
    (highlight-indent-guides-mode)))

(use-package highlight-indent-guides
  :hook (prog-mode . thornemacs/enable-indent-guides-safe)
  :config
  (setq highlight-indent-guides-method 'character
        highlight-indent-guides-auto-enabled t
        highlight-indent-guides-responsive 'top))
#+end_src

*** Rainbow Mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :hook (prog-mode . rainbow-mode))
#+end_src

*** Smartparens

#+begin_src emacs-lisp
  (use-package smartparens
    :init (smartparens-global-mode)
    :hook (prog-mode . smartparens-mode)
    :config
    (require 'smartparens-config))
#+end_src

** Navigation

*** Which-key

#+begin_src emacs-lisp
    (use-package which-key
      :defer 1
      :config
      (which-key-mode)
      (setq which-key-idle-delay 0.3))
#+end_src

*** Avy

#+begin_src emacs-lisp
    (use-package avy
      :bind (("M-s" . avy-goto-char-timer)
             ("M-g c" . avy-goto-char)
             ("M-g w" . avy-goto-word-1)))
#+end_src

*** Consult

#+begin_src emacs-lisp
    (use-package consult
      :bind (("C-s" . consult-line)
             ("C-x b" . consult-buffer)
             ("M-g g" . consult-goto-line)
             ("M-g M-g" . consult-goto-line)))
#+end_src


*** Embark
#+begin_src emacs-lisp
    (use-package embark
      :bind (("C-." . embark-act)
             ("C-;" . embark-dwim)
             ("C-h B" . embark-bindings))
      :init
      (setq embark-action-indicator
            (lambda (&optional _)
              (which-key--show-keymap "Embark Actions" embark--keymap nil nil t)))
      (setq embark-become-indicator embark-action-indicator))
#+end_src

*** Orderless
#+begin_src emacs-lisp
    (use-package orderless
      :init
      (setq completion-styles '(orderless)
            completion-category-defaults nil
            completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Vertico
#+begin_src emacs-lisp
  (use-package vertico
    :init
    (setq vertico-cycle t)
    (vertico-mode))
#+end_src

*** Marginalia

#+begin_src emacs-lisp
    (use-package marginalia
      :init (marginalia-mode))
#+end_src

*** Dirvish
#+begin_src emacs-lisp
(use-package dirvish
  :after evil
  :init
  (dirvish-override-dired-mode)
  :config
  (setq dirvish-default-layout '(0 0.25 0.75))
  (setq dirvish-mode-line-format
        '(:left (sort symlink) :right (omit yank index)))
  (setq dirvish-header-line-height 24)

  ;; Explicitly bind Evil keys to Dirvish (NOT using evil-collection)
  (with-eval-after-load 'dirvish
    (evil-define-key 'normal dirvish-mode-map
      "h" #'dired-up-directory
      "l" #'dired-find-file
      "q" #'quit-window
      "gg" #'revert-buffer
      ;; You can add more custom bindings here
      ))

  ;; Optional: if you want Enter (RET) to open files too
  (with-eval-after-load 'dirvish
    (evil-define-key 'normal dirvish-mode-map
      (kbd "RET") #'dired-find-file))
)
#+end_src

** Direnv

#+begin_src emacs-lisp
(use-package envrc
  :demand t  ; Load immediately instead of deferring
  :config
  (envrc-global-mode)

  ;; Activate envrc before starting LSP to ensure correct environment
  (defun thornemacs/ensure-envrc-before-lsp ()
    "Make sure envrc is activated before LSP starts."
    (when (and (buffer-file-name)
              (not envrc--status))
      (envrc-mode 1)
      (envrc-reload)))

  ;; Add this hook to prog-mode which will run before our LSP hooks
  (add-hook 'prog-mode-hook #'thornemacs/ensure-envrc-before-lsp '5))
#+end_src

** LSP

*** Auto-completion

#+begin_src emacs-lisp
  (use-package company
    :init (global-company-mode)
    :hook ((prog-mode . company-mode)
  	 (org-mode . company-mode)
  	 (emacs-lisp-mode . company-mode))
    :config
    (setq company-idle-delay 0
          company-minimum-prefix-length 1
          company-selection-wrap-around t
          company-tooltip-align-annotations t
          company-frontends '(company-pseudo-tooltip-frontend))
    (define-key company-active-map (kbd "<tab>") #'company-complete-selection)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "RET") nil))
#+end_src


*** Togglable LSP System

#+begin_src emacs-lisp
;; Define the LSP choice customization
(defcustom thornemacs/lsp-backend 'eglot
  "The LSP backend to use. Either 'eglot or 'lsp-mode."
  :type '(choice (const :tag "Eglot" eglot)
                (const :tag "LSP Mode" lsp-mode))
  :group 'thornemacs)

;; Interactive function to toggle LSP backend
(defun thornemacs/toggle-lsp-backend ()
  "Toggle between `eglot` and `lsp-mode` and restart the LSP session accordingly."
  (interactive)
  (let ((new-backend (if (eq thornemacs/lsp-backend 'eglot)
                         'lsp-mode
                       'eglot)))
    (setq-default thornemacs/lsp-backend new-backend)
    (setq thornemacs/lsp-backend new-backend)
    (message "LSP backend set to %s" new-backend)

    ;; Clean up old LSP sessions if running
    (cond
     ((and (fboundp 'eglot-shutdown-all)
           (bound-and-true-p eglot--managed-mode))
      (eglot-shutdown-all)
      (message "Stopped Eglot"))

     ((and (fboundp 'lsp-disconnect)
           (bound-and-true-p lsp-mode))
      (lsp-disconnect)
      (message "Stopped LSP Mode")))

    ;; Restart the new one after a short delay
    (run-with-timer
     1 nil
     (lambda ()
       (pcase new-backend
         ('eglot
          (message "Restarting with Eglot...")
          (eglot-ensure))
         ('lsp-mode
          (message "Restarting with LSP Mode...")
          (lsp-deferred)))))))

;; Keybinding for toggling
(global-set-key (kbd "C-c t l") 'thornemacs/toggle-lsp-backend)

;; Safer format on save function
(defun thornemacs/lsp-format-buffer-on-save ()
  "Add appropriate format-on-save hook based on selected backend with safety checks."
  (if (eq thornemacs/lsp-backend 'eglot)
      (add-hook 'before-save-hook
                (lambda ()
                  ;; For org-mode, don't use LSP formatting
                  (if (eq major-mode 'org-mode)
                      (message "Skipping LSP format in org-mode")
                    ;; Otherwise, check if LSP is actually connected before formatting
                    (when (and (fboundp 'eglot-managed-p)
                               (eglot-managed-p)
                               (eglot-current-server))
                      (eglot-format-buffer))))
                -10 t)
    ;; LSP-mode version
    (add-hook 'before-save-hook
              (lambda ()
                ;; For org-mode, don't use LSP formatting
                (if (eq major-mode 'org-mode)
                    (message "Skipping LSP format in org-mode")
                  ;; Otherwise, check if LSP is actually connected
                  (when (and (bound-and-true-p lsp-mode)
                             (lsp-workspaces))
                    (lsp-format-buffer))))
              -10 t)))

(defun thornemacs/start-lsp ()
  "Start the selected LSP backend with special handling for org-mode."
  (if (eq major-mode 'org-mode)
      (thornemacs/lsp-format-buffer-on-save)
    (condition-case err
        (progn
          (cond
           ((eq thornemacs/lsp-backend 'eglot)
            (require 'eglot)
            (eglot-ensure))

           ((eq thornemacs/lsp-backend 'lsp-mode)
            (require 'lsp-mode)
            (lsp-deferred)))

          (thornemacs/lsp-format-buffer-on-save))
      (error (message "Could not start LSP: %s" (error-message-string err))))))

;; Support for LSP in org-babel code blocks
;; (defun thornemacs/setup-org-babel-lsp ()
;;   "Set up LSP support for org-babel code blocks."
;;   ;; Enable company mode for completions
;;   (company-mode +1)
;;
;;   ;; Add hooks for org-src-mode
;;   (add-hook 'org-src-mode-hook
;;             (lambda ()
;;               ;; When editing a source block, make sure the right LSP is loaded
;;               (when (org-src-edit-buffer-p) ;; Check if this is actually a src edit buffer
;;                 (let ((lang (when (boundp 'org-src-lang-modes)
;;                               (org-src-get-lang-mode (car (org-babel-get-src-block-info t))))))
;;                   ;; Only try to activate LSP for programming languages
;;                   (when (and lang (derived-mode-p 'prog-mode))
;;                     ;; Make sure direnv is loaded
;;                     (thornemacs/ensure-envrc-before-lsp)
;;                     ;; Start LSP with a small delay
;;                     (run-with-timer 0.5 nil #'thornemacs/start-lsp)))))))
#+end_src

*** LSP Packages Configuration

#+begin_src emacs-lisp
;; Install and configure both packages
(use-package eglot
  :commands (eglot eglot-ensure)
  :config
  (setq eglot-autoshutdown t))

(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :config
  (setq lsp-completion-provider :capf
        lsp-headerline-breadcrumb-enable nil
        lsp-enable-on-type-formatting nil
        lsp-enable-snippet nil
        lsp-modeline-diagnostics-enable t))

(use-package eldoc-box
  :commands (eldoc-box-hover-at-point-mode)
  :hook ((eglot-managed-mode . eldoc-box-hover-at-point-mode)
         (lsp-mode . eldoc-box-hover-at-point-mode)))

;; Add org-mode specific hook for LSP in code blocks
;; (add-hook 'org-mode-hook #'thornemacs/setup-org-babel-lsp)
#+end_src

*** Language-specific LSP Setup

#+begin_src emacs-lisp

;; Install language modes
(use-package rustic)
(use-package go-mode)
(use-package nix-mode)
(use-package ccls)

;; Set up LSP hooks with our dynamic system
(defun thornemacs/setup-lang-lsp-hooks ()
  "Add LSP hooks for all supported languages."
  (dolist (mode-hook '(rustic-mode-hook
                      go-mode-hook
                      nix-mode-hook
                      ccls-hook
                      c-mode-hook
                      c++-mode-hook))

    ;; Add our dynamic LSP starter after loading direnv
    (add-hook mode-hook
              (lambda ()
                ;; Make sure envrc has run first
                (thornemacs/ensure-envrc-before-lsp)
                ;; Add a small delay to ensure env is fully loaded
                (run-with-timer 0.5 nil #'thornemacs/start-lsp))
              15)))

;; Run the hook setup
(thornemacs/setup-lang-lsp-hooks)

;; Now ensure org-babel code blocks get proper LSP support when editing
;; (with-eval-after-load 'org
;;   (advice-add 'org-edit-src-code :after
;;               (lambda (&rest _)
;;                 (when (and (derived-mode-p 'prog-mode)
;;                            (boundp 'org-src-source-file-name)
;;                            org-src-source-file-name)
;;                   ;; Check if this is a language we'd want LSP for
;;                   (let ((lang (when (and (markerp org-src-source-file-name)
;;                                        (marker-buffer org-src-source-file-name))
;;                                (buffer-local-value 'org-src-lang-modes
;;                                                   (marker-buffer org-src-source-file-name)))))
;;                     (when (and lang (member lang '("rustic" "rust" "go" "nix" "c" "c++" "emacs-lisp")))
;;                       ;; Start LSP for this edit session
;;                       (thornemacs/ensure-envrc-before-lsp)
;;                       (run-with-timer 0.3 nil ;;'thornemacs/start-lsp)))))))

(with-eval-after-load 'org
  ;; Ensure org mode is properly loaded
  (require 'org)
  (require 'org-element)

  ;; Rest of your org configuration
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((rust . t)
     (nix . t)
     (org . t)
     (emacs-lisp .t))))
#+end_src

*** Org-Integration

#+begin_src emacs-lisp
(defun thornemacs/start-lsp-manually-for-lang (lang)
  "Start LSP for a specific language in org-mode code blocks."
  (interactive "sEnter language (e.g., rust, go, nix): ")
  (let ((lang-mode (intern (concat lang "-mode"))))
    (if (functionp lang-mode)
        (progn
          (funcall lang-mode) ;; Enable the language mode
          (thornemacs/start-lsp)) ;; Start LSP
      (message "No mode found for language: %s" lang))))

(global-set-key (kbd "C-c t m") 'thornemacs/start-lsp-manually-for-lang)
#+end_src

*** Modeline-Integration (WIP)

#+begin_src emacs-lisp
#+end_src

** Org

*** General Settings

#+begin_src emacs-lisp
  ;; Auto line wrap
  (add-hook 'org-mode-hook #'auto-fill-mode)

  ;; Indentation for headings and lists
  (add-hook 'org-mode-hook #'org-indent-mode)

  ;; Visual wrapping (soft word wrap)
  (add-hook 'org-mode-hook #'visual-line-mode)

  ;; Optional: Edit code blocks neatly
  (setq org-edit-src-content-indentation 0)
#+end_src

*** Org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :after org
  :config
  (global-org-modern-mode))
#+end_src

*** Org-babel

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((rust . t)
     (nix . t)
     (org . t)
     (emacs-lisp . t))))
#+end_src

*** Org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :custom (org-roam-directory "~/org-roam")
  :config (org-roam-db-autosync-mode))
#+end_src


** Magit

#+begin_src emacs-lisp
(use-package magit
  :commands (magit-status magit-log-current magit-blame)
  :bind (("C-x g" . magit-status)         ;; Shortcut to open Magit Status
         ("C-x C-g" . magit-dispatch)    ;; Magit dispatch for other actions
         ("C-x M-g" . magit-blame))       ;; Shortcut for Magit Blame
  :config
)
#+end_src

* TO-DO

- [ ] Implement more colorschemes because I like way too many of them.
- [ ] Add the option for overrides...bc nix.
- [ ] Add custom banners and footers.
- [ ] Whatever else I come up with lmao.

* Credits

- [[https://github.com/iynaix][@iynaix]]:
  - Get with the program already folks! I +stole+ took inspiration
    from [[https://github.com/iynaix/focal][iynaix/focal]] for the flake as well as this README.

- [[https://codeberg.org/acidbong][@acidbong]]:
  - For helping my sorry ass over on the [[https://matrix.to/#/#emacs:nixos.org][Nix Emacs]] matrix space.
  - And for providing this very helpful [[https://codeberg.org/acidbong/nixos/src/branch/master/pkgs/emacs][configuration]] for me to +steal+ take
    inspiration from.
